% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ReconstFun.R
\name{reconstruct}
\alias{reconstruct}
\title{Reconstruct partially observed functions}
\usage{
reconstruct(Ly, Lu, K = NULL, K_max = 4, method = c("PS_TRUE", "PS_FALSE",
  "CEScores")[3], BwMu = NULL, BwCov = NULL, reconst_fcts = NULL,
  nRegGrid = 51, messages = FALSE)
}
\arguments{
\item{Ly}{List of Y-values. The ith (i=1,...,n) list-element contains \eqn{Y_{i1},\dots,Y_{im}}{Y_{i1},...,Y_{im}}}

\item{Lu}{List of U-values. The ith (i=1,...,n) list-element contains \eqn{U_{i1},\dots,U_{im}}{U_{i1},...,U_{im}}}

\item{K}{Truncation parameter. If K=NULL (default), K is determined using an AIC-type criterion.}

\item{K_max}{Maximum K (used in the AIC-type criterion)}

\item{method}{If method=PS_TRUE:  Pre-smoothing of the 'observed' part (Reconstruction operator: \eqn{L^*}{L*}). If method=PS_FALSE: FPCA-estimation of the 'observed' part (Reconstruction operator: \eqn{L}{L}). If method=CEScores: FPCA-estimation of the 'observed' part with CEScores from the fdapace package.}

\item{BwMu}{Bandwidth for estimating the mean function (default: 0.05 of the support)}

\item{BwCov}{Bandwidth for estimating the cov function (default: 0.10 of the support)}

\item{reconst_fcts}{A vector specifying the list elements in Ly which need to be reconstructed. Default (reconst_fcts=NULL) will reconstruct all functions.}

\item{nRegGrid}{Number of grid-points used for the equidistant 'workGrid'; needed for the fdapace::FPCA() function among others.}

\item{messages}{Printing messages? (default: messages=FALSE)}
}
\description{
This function allows you to reconstruct the missing parts of a function given the observed parts.
}
\examples{
 
a <- 0; b <- 1
SimDat        <- simuldata(n = 50, a = a, b = b, DGP="DGP3")
## 
Y_list   <- SimDat[['Y_list']]; Y_mat <- SimDat[['Y_mat']]
U_list   <- SimDat[['U_list']]; U_mat <- SimDat[['U_mat']]
##
reconst_result_1 <- reconstruct(Ly = Y_list, Lu = U_list, method = "PS_TRUE",
reconst_fcts = 1:3)
Y_reconst_mat_1  <- matrix(unlist(reconst_result_1[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_1  <- matrix(unlist(reconst_result_1[['U_reconst_list']]), ncol=3) 
##
reconst_result_2 <- reconstruct(Ly = Y_list, Lu = U_list, method = "PS_FALSE", 
reconst_fcts = 1:3)
Y_reconst_mat_2  <- matrix(unlist(reconst_result_2[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_2  <- matrix(unlist(reconst_result_2[['U_reconst_list']]), ncol=3) 
##
reconst_result_3 <- reconstruct(Ly = Y_list, Lu = U_list, method = "CEScores",
reconst_fcts = 1:3)
Y_reconst_mat_3  <- matrix(unlist(reconst_result_3[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_3  <- matrix(unlist(reconst_result_3[['U_reconst_list']]), ncol=3) 
##
par(mfrow=c(2,2))
matplot(x=U_mat[,1:3], y=Y_mat[,1:3], ylab="", col=gray(.5), type="l", 
main="Orig. Data", xlim=c(a,b))
matplot(x=U_reconst_mat_1, y=Y_reconst_mat_1, col=gray(.5), 
type="l", main="PS_TRUE", ylab="", xlab="", xlim=c(a,b))
matplot(x=U_reconst_mat_2, y=Y_reconst_mat_2, col=gray(.5), 
type="l", main="PS_FALSE", ylab="", xlab="", xlim=c(a,b))
matplot(x=U_reconst_mat_3, y=Y_reconst_mat_3, col=gray(.5), 
type="l", main="CEScores", ylab="", xlab="", xlim=c(a,b))
par(mfrow=c(1,1))
}
