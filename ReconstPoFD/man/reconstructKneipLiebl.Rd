% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/KneipLieblFun.R
\name{reconstructKneipLiebl}
\alias{reconstructKneipLiebl}
\title{Reconstruct partially observed functions}
\usage{
reconstructKneipLiebl(Ly, Lu, reconst_fcts = NULL,
  method = c("Error=0_AlignYES_CommonGrid", "Error>0_AlignYES",
  "Error>=0_AlignNO", "Error>0_AlignYES_CEscores", "Error>0_AlignNO_CEscores",
  "PACE"), K = NULL, nRegGrid = NULL, maxbins = NULL, progrbar = FALSE)
}
\arguments{
\item{Ly}{List of Y-values. The ith (i=1,...,n) list-element contains \eqn{Y_{i1},\dots,Y_{im}}{Y_{i1},...,Y_{im}}}

\item{Lu}{List of U-values. The ith (i=1,...,n) list-element contains \eqn{U_{i1},\dots,U_{im}}{U_{i1},...,U_{im}}}

\item{reconst_fcts}{A vector specifying the list elements in Ly which need to be reconstructed. Default (reconst_fcts=NULL) will reconstruct all functions.}

\item{method}{One of the following options: c('Error=0_AlignYES_CommonGrid', 'Error>0_AlignYES', 'Error>=0_AlignNO', 'Error>0_AlignYES_CEscores','Error>0_AlignNO_CEscores')}

\item{K}{Truncation parameter. If K=NULL (default), K is determined using an AIC-type criterion.}

\item{nRegGrid}{Number of gridpoints within used for the reconstruction result.}

\item{maxbins}{If maxbins=NULL (default), maxbins is set to 1000. For speeding up simulations, use, for instance maxbins=100.}

\item{progrbar}{Show progress bar (TRUE) or not (FALSE, default)}
}
\description{
This function allows you to reconstruct the missing parts of a function given the observed parts.
}
\examples{
 

a <- 0; b <- 1
set.seed(223109)

## Generate partially observed functional data with error
SimDat        <- simuldata(n = 50, m=15, a = a, b = b, DGP="DGP1")
## 
Y_list   <- SimDat[['Y_list']]; Y_mat <- SimDat[['Y_mat']]
U_list   <- SimDat[['U_list']]; U_mat <- SimDat[['U_mat']]
##
## Reconstruction with alignments of reconstructed parts and presmoothed fragments
## Classical scores
reconst_result_1 <- reconstructKneipLiebl(Ly = Y_list, Lu = U_list, 
method = 'Error>0_AlignYES', reconst_fcts = 1:3)
Y_reconst_mat_1  <- matrix(unlist(reconst_result_1[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_1  <- matrix(unlist(reconst_result_1[['U_reconst_list']]), ncol=3) 
##
## Reconstruction with out alignments
## Classical scores
reconst_result_2 <- reconstructKneipLiebl(Ly = Y_list, Lu = U_list, 
method = 'Error>=0_AlignNO', reconst_fcts = 1:3)
Y_reconst_mat_2  <- matrix(unlist(reconst_result_2[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_2  <- matrix(unlist(reconst_result_2[['U_reconst_list']]), ncol=3) 
##
par(mfrow=c(1,3))
matplot(x=U_mat[,1:3], y=Y_mat[,1:3], ylab="", col=gray(.5), type="l", 
main="Orig. Data", xlim=c(a,b))
matplot(x=U_reconst_mat_1, y=Y_reconst_mat_1, col=gray(.5), 
type="l", main="With Alignment", ylab="", xlab="", xlim=c(a,b))
matlines(x=U_mat[,1:3], y=Y_mat[,1:3], col=gray(.2), lwd=2) 
matplot(x=U_reconst_mat_2, y=Y_reconst_mat_2, col=gray(.5), 
type="l", main="Without Alignment", ylab="", xlab="", xlim=c(a,b))
matlines(x=U_mat[,1:3], y=Y_mat[,1:3], col=gray(.2), lwd=2)
par(mfrow=c(1,1))


## Reconstruction with alignments of reconstructed parts and presmoothed fragments
## PACE scores
reconst_result_1 <- reconstructKneipLiebl(Ly = Y_list, Lu = U_list, 
method = 'Error>0_AlignYES_CEscores', reconst_fcts = 1:3)
Y_reconst_mat_1  <- matrix(unlist(reconst_result_1[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_1  <- matrix(unlist(reconst_result_1[['U_reconst_list']]), ncol=3) 
##
## Reconstruction with out alignments
## PACE scores
reconst_result_2 <- reconstructKneipLiebl(Ly = Y_list, Lu = U_list, 
method = 'Error>0_AlignNO_CEscores', reconst_fcts = 1:3)
Y_reconst_mat_2  <- matrix(unlist(reconst_result_2[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_2  <- matrix(unlist(reconst_result_2[['U_reconst_list']]), ncol=3) 
##
par(mfrow=c(1,3))
matplot(x=U_mat[,1:3], y=Y_mat[,1:3], ylab="", col=gray(.5), type="l", 
main="Orig. Data", xlim=c(a,b))
matplot(x=U_reconst_mat_1, y=Y_reconst_mat_1, col=gray(.5), 
type="l", main="With Alignment", ylab="", xlab="", xlim=c(a,b))
matlines(x=U_mat[,1:3], y=Y_mat[,1:3], col=gray(.2), lwd=2) 
matplot(x=U_reconst_mat_2, y=Y_reconst_mat_2, col=gray(.5), 
type="l", main="Without Alignment", ylab="", xlab="", xlim=c(a,b))
matlines(x=U_mat[,1:3], y=Y_mat[,1:3], col=gray(.2), lwd=2)
par(mfrow=c(1,1))


##
## Generate partially observed functional data without error 
SimDat        <- simuldata(n = 50, a = a, b = b, DGP="DGP3")
## 
Y_list   <- SimDat[['Y_list']]; Y_mat <- SimDat[['Y_mat']]
U_list   <- SimDat[['U_list']]; U_mat <- SimDat[['U_mat']]
##
## Reconstruction with alignments of reconstructed parts and observed fragments
reconst_result_1 <- reconstructKneipLiebl(Ly = Y_list, Lu = U_list, 
method = 'Error=0_AlignYES_CommonGrid', reconst_fcts = 1:3)
Y_reconst_mat_1  <- matrix(unlist(reconst_result_1[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_1  <- matrix(unlist(reconst_result_1[['U_reconst_list']]), ncol=3) 
##
## Reconstruction without alignments
reconst_result_2 <- reconstructKneipLiebl(Ly = Y_list, Lu = U_list, 
method = 'Error>=0_AlignNO', reconst_fcts = 1:3)
Y_reconst_mat_2  <- matrix(unlist(reconst_result_2[['Y_reconst_list']]), ncol=3) 
U_reconst_mat_2  <- matrix(unlist(reconst_result_2[['U_reconst_list']]), ncol=3) 
##
par(mfrow=c(1,3))
matplot(x=U_mat[,1:3], y=Y_mat[,1:3], ylab="", col=gray(.5), type="l", 
main="Orig. Data", xlim=c(a,b))
matplot(x=U_reconst_mat_1, y=Y_reconst_mat_1, col=gray(.5), 
type="l", main="With Alignment", ylab="", xlab="", xlim=c(a,b))
matlines(x=U_mat[,1:3], y=Y_mat[,1:3], col=gray(.2), lwd=2) 
matplot(x=U_reconst_mat_2, y=Y_reconst_mat_2, col=gray(.5), 
type="l", main="Without Alignment", ylab="", xlab="", xlim=c(a,b))
matlines(x=U_mat[,1:3], y=Y_mat[,1:3], col=gray(.2), lwd=2)
par(mfrow=c(1,1))
}
